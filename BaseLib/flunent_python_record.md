# FluntPython 记录
实例代码在https://github.com/fluentpython/example-code
## ch3 Dict and Set
- 往字典里添加新建可能会改变已有键的顺序
> 无论何时往字典里添加新的键，Python 解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。要注意的是，上面提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，因此你不能很自信地说自己知道背后发生了什么。如果你在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很有可能会跳过一些键——甚至是跳过那些字典中已经有的键。

**由此可知，不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分成两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；迭代结束之后再对原有字典进行更新（Update方法）。**
- set 和dict的特点：
  - 里面的元素必须是可散列的（可哈希的）
  - dict/set很消耗内存
  - 两者可以很高效地判断元素是否存在于某个集合
  - 元素的次序取决于被添加到集合/字典里的次序
  - 往集合或字典里添加元素，可能会改变即合理已有的元素顺序

## ch4 文本和字节序列
- 概念：
  - 字符的标识，即码位，Unicode用4-6个十六进制的数字表示，用U打头
  - 字节序列，是字符的编码方式。如UTF8， 一般b打头
  - 讲字符串转换为机器识别的字节序列为编码encode(),而将字节序列转换成字符串是解码过程decode()

- python3内置了两种字节序列：bytes(不可变) 和 bytearray（可变）。 其各个元素是range(256)的整数，虽然二进制序列其实是整数序列，但是二进制序列都可以使用str对象的方法。

- 实现bytes或bytearray实例可以传入如下参数：
  - 一个str对象和一个encoding关键字
  - 一个可迭代对象，提供0-255数值
  - 一个实现了**缓冲协议**的对象（如bytes, bytearray, **memoryview**, array.array）； 使用缓冲类对象创建字节学列时，始终**复制**源对象中的字节序列，与之相反，memoryview对象允许在二进制数据结构间**共享内存**

- struct 模块可以帮助我们从bytes和memeoryview中提取结构化信息，在频繁地对二进制io操作时可以使用词模块

- 编码中的问题
  - UnicodeEncodeError错误出现在encode（'非utf_x'）时，utf_8能做到对所有字符编码，但其他的编码方式不一定。此时制定errors = 'ignore'或者'replace'替换为？.
  - UnicodeDecodeError,此错误出现在对字节序列解码时使用了不对应的编码方式。常常会出现乱码

- 处理文本文件
  - 处理文本文件的最佳方式是在业务逻辑代码环节只操作unicode, io操作字节序列。这一过程python3的read和open都已经实现了。
  - 但要注意的是，read()一个文件的时候不要依赖默认编码。open('...','r')的默认编码是系统默认编码，Linux和MacOS都是默认utf8，所以读写都不会出问题。但win默认的是cp2123,此时如果写入时制定编码utf8, 而读出时依赖系统默认编码就会出现乱码。
  - 'rb'选项读出的是字节序列。一般不是要判断字符编码方式不推荐使用此模式

- Unicode麻烦的问题在于非ASCII字符的比较和排序上（**因为unicode为某些字符提供了不同的表示**）。使用全局码和区间域的设置可以解决不同语言的比较和排序问题；PyUCA库也是专门用用来解决此问题的

- 支持字符串和字节序列的双模式API。如re 和 os模块就实现了双模式的输入。r'\d' 和rb'\d' 识别不同模式下的ASCII数字。 os中的路径也可以传入b'' 返回的也是字节序列的文件名称。

> Python3在RAM中如何表示字符串？ 在内存中，Python3使用固定数量的字节存储字符串的各个码位，以便高效访问各个字符或切片。在创建str时，解释器会检查里面的字符，然后为该字符选择最经济的内存布局（如2个或4个字节，中文大多数字两个字节够用）

## Ch5 一等函数
- 在Python中，函数被称为一等对象。因为他满足以下特点
  - 在运行时创建
  - 能赋值给变量或数据结构中的元素
  - 能作为函数参数传递
  - 能作为函数返回

- 可调用类型（callable）是可用使用（）的对象， 实现了__call__方法后对象实例也可为可调用对象，可以用内置函数callbale()判断是否为可调用对象。（生成器也是一种特殊的可调用对象）

- 函数对象有个 __defaults__ 属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字参数的默认值在__kwdefaults__ 属性中。然而，参数的名称在 __code__ 属性中，它的值是一个 code 对象引用，自身也有很多属性。**inspect** 模块可以帮助我们查查看参数的对应情况

- 为函数编写的注解默认储存在内省方法__annotation__中

- 支持函数式编程的包
  - Operator模块， 如itemgetter()和attrgetter()方法
  - functools模块
    - functools.partial会冻结原函数的某个参数返回只调用部分参数的新的回调对象
    - lru_cache 函数令人印象深刻，它会做备忘（memoization），这是一种自动优化措施，它会存储耗时的函数调用结果，避免重新计算。

## Ch6 使用一等函数实现设计模式
> ：“对接口编程，而不是对实现编程”和“优先使用对象组合，而不是类继承”。
------ 《设计模式：可复用面向对象软件的基础》

模块也是一等对象，内置globals()函数可以查看当前模块所有内置对象

## ch7 函数装饰器和闭包
- 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。大多数装饰器会在内部定义一个函数，然后将其返回。（多数装饰器都会修改函数）
;装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。

- 函数闭包的概念要先明白Python3的变量作用域
  - Python不要求声明变量，但是嘉定在函数定义体中赋值的变量是局部变量。
  - 如果在函数中赋值时想让解释器吧某变量当做全局变量，要使用**global**声明。

- 闭包是一种函数，它会保留定义函数时存在的**自由变量**的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。**注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。**
![](https://ws1.sinaimg.cn/large/6af92b9fgy1fy7s2z1lnhj20nj0bmad0.jpg)

-  Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 nonlocal 声明的变量赋予新值，闭包中保存的绑定会更新。
```python
def make_average():
  count = 0
  total = 0
  def averager(new_value):
    nonlocal count, total
    count += 1
    total += new_value
    return total / count
  return averager
```

- 标准库中的装饰器
  - functools.lru_cache 是非常实用的装饰器，它实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU 三个字母是“LeastRecently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。
  - **因为Python不支持方法的重载** functools.singledispatch 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用@singledispatch 装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。

  ```python
  from functools import singledispatch
  from collections import abc
  import numbers
  import html
  @singledispatch ➊
  def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)
  @htmlize.register(str) ➋
  def _(text): ➌
    content = html.escape(text).replace('\n', '<br>\n')
    return '<p>{0}</p>'.format(content)
  @htmlize.register(numbers.Integral) ➍
  def _(n):
    return '<pre>{0} (0x{0:x})</pre>'.format(n)
  @htmlize.register(tuple) ➎
  @htmlize.register(abc.MutableSequence)
  def _(seq):
    inner = '</li>\n<li>'.join(htmlize(item) for item in seq)
    return '<ul>\n<li>' + inner + '</li>\n</ul>'
  ```
- 参数化装饰器
  参数化装饰器是指实现对装饰器的传参一般在原先基础上再实现一层嵌套

  ```python
  def Wrapper(outer_param):
      def decorate(func):
          def inner(*args):
            """
              内部逻辑
            """
          return func
      return inner
    return decorate
  ```

## 对象引用，可变性和垃圾回收
- == 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。

- **元组的相对不可变性** ： 元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象的引用。 如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

- 浅复制；
  - 对可变对象（如list）进行+=操作会就地改变对象。对不可变对象（如元组）进行+=操作会创建新的对象
  - 利用构造方法list() 和 list[:]都是对列表的潜复制

  ```python
    l1 = [3, [66, 55, 44], (7, 8, 9)]
    l2 = list(l1) # ➊
    l1.append(100) # ➋
    l1[1].remove(55) # ➌
    print('l1:', l1)
    print('l2:', l2)
    l2[1] += [33, 22] # ➍
    l2[2] += (10, 11) # ➎
    print('l1:', l1)
    print('l2:', l2)
  ```
  ![](https://ws1.sinaimg.cn/large/6af92b9fgy1fy8e1aqfngj20dk0e374y.jpg)
  > Python Tutor是一个可视化代码之行过程的网站

- 为任意对象实现深浅复制： copy()函数和copy模块的deepcopy可以实现浅复制和深复制（不共享引用）；但是deepcopy有时很耗时，最好实现对象的__copy__ 和__deepcopy__方法自定义复制行为

- 函数的参数作为引用时：
  - 函数可能会修改接收到的任何可变对象
  - **不要使用可变类型作为参数的默认值** (默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。)最好默认为None
  - 对于类的方法，除非这个方法确实想修改通过参数传入的对象，否则在类中直接把参数赋值给实例变量之前一定要三思，因为这样会为参数对象创建别名。如果不确定，那就创建副本。这样客户会少些麻烦。

- del和垃圾回收
  - del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。
  - 在 CPython 中，垃圾回收使用的主要算法是**引用计数**。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁：CPython 会在对象上调用 __del__ 方法（如果定义了），然后释放分配给对象的内存。

- 弱引用 弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。可以用**weakref.ref**获取引用对象

## Ch9 Python风格的对象
- 自定义构造类
  - __iter__ 使得类实例变为可迭代对象进而可以进行**拆包**操作。 此方法可以简单地定义成生成器
  - __str__ __repr__ 定义类的描述
  - __bytes__ 定义返回字节形式 与bytes()函数对应
  - __eq__ 定义比较方式
  - __hash__ 使对象可散列（不可变）

- @classmethod 和 @staticmethod
  - classmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod 最常见的用途是定义备选构造方法
  - staticmethod 就是普通的静态方法

- python类的私有属性用__x双下划线定义，其实是实现了改名机制；也有约定俗称地用_x单下划线表示私有属性

- __slots__ 节省内存机制；在类中定义 __slots__ 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的 __dict__ 属性。如果有数百万个实例同时活动，这样做能节省大量内存。
如果你的程序不用处理数百万个实例，或许不值得费劲去创建不寻常的
类，那就禁止它创建动态属性或者不支持弱引用。与其他优化措施一
样，仅当权衡当下的需求并仔细搜集资料后证明确实有必要时，才应该
使用 __slots__ 属性。

- 
