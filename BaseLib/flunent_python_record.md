# FluntPython 记录
实例代码在https://github.com/fluentpython/example-code
## ch3 Dict and Set
- 往字典里添加新建可能会改变已有键的顺序
> 无论何时往字典里添加新的键，Python 解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。要注意的是，上面提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，因此你不能很自信地说自己知道背后发生了什么。如果你在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很有可能会跳过一些键——甚至是跳过那些字典中已经有的键。

**由此可知，不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分成两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；迭代结束之后再对原有字典进行更新（Update方法）。**
- set 和dict的特点：
  - 里面的元素必须是可散列的（可哈希的）
  - dict/set很消耗内存
  - 两者可以很高效地判断元素是否存在于某个集合
  - 元素的次序取决于被添加到集合/字典里的次序
  - 往集合或字典里添加元素，可能会改变即合理已有的元素顺序

## ch4 文本和字节序列
- 概念：
  - 字符的标识，即码位，Unicode用4-6个十六进制的数字表示，用U打头
  - 字节序列，是字符的编码方式。如UTF8， 一般b打头
  - 讲字符串转换为机器识别的字节序列为编码encode(),而将字节序列转换成字符串是解码过程decode()
- python3内置了两种字节序列：bytes(不可变) 和 bytearray（可变）。 其各个元素是range(256)的整数，虽然二进制序列其实是整数序列，但是二进制序列都可以使用str对象的方法。
- 实现bytes或bytearray实例可以传入如下参数：
  - 一个str对象和一个encoding关键字
  - 一个可迭代对象，提供0-255数值
  - 一个实现了**缓冲协议**的对象（如bytes, bytearray, **memoryview**, array.array）； 使用缓冲类对象创建字节学列时，始终**复制**源对象中的字节序列，与之相反，memoryview对象允许在二进制数据结构间**共享内存**
- struct 模块可以帮助我们从bytes和memeoryview中提取结构化信息，在频繁地对二进制io操作时可以使用词模块
- 编码中的问题
  - UnicodeEncodeError错误出现在encode（'非utf_x'）时，utf_8能做到对所有字符编码，但其他的编码方式不一定。此时制定errors = 'ignore'或者'replace'替换为？.
  - UnicodeDecodeError,此错误出现在对字节序列解码时使用了不对应的编码方式。常常会出现乱码
- 处理文本文件
  - 处理文本文件的最佳方式是在业务逻辑代码环节只操作unicode, io操作字节序列。这一过程python3的read和open都已经实现了。
  - 但要注意的是，read()一个文件的时候不要依赖默认编码。open('...','r')的默认编码是系统默认编码，Linux和MacOS都是默认utf8，所以读写都不会出问题。但win默认的是cp2123,此时如果写入时制定编码utf8, 而读出时依赖系统默认编码就会出现乱码。
  - 'rb'选项读出的是字节序列。一般不是要判断字符编码方式不推荐使用此模式
- Unicode麻烦的问题在于非ASCII字符的比较和排序上（**因为unicode为某些字符提供了不同的表示**）。使用全局码和区间域的设置可以解决不同语言的比较和排序问题；PyUCA库也是专门用用来解决此问题的
- 支持字符串和字节序列的双模式API。如re 和 os模块就实现了双模式的输入。r'\d' 和rb'\d' 识别不同模式下的ASCII数字。 os中的路径也可以传入b'' 返回的也是字节序列的文件名称。

> Python3在RAM中如何表示字符串？ 在内存中，Python3使用固定数量的字节存储字符串的各个码位，以便高效访问各个字符或切片。在创建str时，解释器会检查里面的字符，然后为该字符选择最经济的内存布局（如2个或4个字节，中文大多数字两个字节够用）

## Ch5 一等函数
- 在Python中，函数被称为一等对象。因为他满足以下特点
  - 在运行时创建
  - 能赋值给变量或数据结构中的元素
  - 能作为函数参数传递
  - 能作为函数返回
- 
